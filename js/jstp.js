// Generated by IcedCoffeeScript 1.6.2d
(function() {
  var Dispatch;



  Dispatch = (function() {
    function Dispatch(options) {
      var key;
      for (key in options) {
        this[key] = options[key];
      }
      if (!this.protocol) {
        this.protocol = ["JSTP", "0.4"];
      }
      if (!this.timestamp) {
        this.timestamp = +new Date().getTime();
      }
      if (!this.token) {
        this.token = JSTP.defaultToken;
      }
      if (!this.referer) {
        this.referer = [];
      }
      if (!this.body) {
        this.body = {};
      }
    }

    Dispatch.prototype.toString = function() {
      return JSON.stringify(this);
    };

    Dispatch.prototype.isGET = function() {
      return this.method.toLowerCase() === "get";
    };

    return Dispatch;

  })();

  this.JSTP = {
    defaultToken: [],
    connections: {},
    bound: [],
    reboundBuffer: {},
    bind: function(pack, callback, context) {
      pack.method = "BIND";
      return this.dispatch(pack, callback, context);
    },
    on: function(pack, callback, context) {
      pack.method = "BIND";
      return this.dispatch(pack, callback, context);
    },
    get: function(pack) {
      pack.method = "GET";
      return this.dispatch(pack, null, null);
    },
    post: function(pack) {
      pack.method = "POST";
      return this.dispatch(pack, null, null);
    },
    patch: function(pack) {
      pack.method = "PATCH";
      return this.dispatch(pack, null, null);
    },
    "delete": function(pack) {
      pack.method = "DELETE";
      return this.dispatch(pack, null, null);
    },
    release: function(pack, callback, context) {
      pack.method = "RELEASE";
      return this.dispatch(pack, callback, context);
    },
    off: function(pack, callback, context) {
      pack.method = "RELEASE";
      return this.dispatch(pack, callback, context);
    },
    dispatch: function(pack, callback, context) {
      pack = new Dispatch(pack);
      if (pack.method.toLowerCase() === "bind") {
        this._bind(pack, callback, context);
      }
      if (pack.host && pack.host.length > 0) {
        return this._sendOrConnect(pack, callback, context);
      } else {
        return this.trigger(pack);
      }
    },
    _sendOrConnect: function(pack, callback, context) {
      var host, packString;
      if (!pack.toString) {
        pack = new Dispatch(pack);
      }
      host = pack.host[0];
      pack.host.splice(0, 1);
      packString = pack.toString();
      if (this.open(host)) {
        return this.send(host, packString);
      } else {
        console.log("Opening socket to " + (host.join(':')));
        return this.connect(host, function() {
          JSTP.send(host, packString);
          packString = null;
          return pack = null;
        });
      }
    },
    _bind: function(pack, callback, context) {
      var callbackObj;
      callbackObj = {
        endpoint: pack.endpoint,
        callback: callback,
        context: context,
        host: pack.host[0]
      };
      return this.bound.push(callbackObj);
    },
    _rebind: function(hostString, doIt) {
      var current, hook, pack, _i, _j, _len, _len1, _ref, _results;
      if (doIt) {
        current = [];
        _ref = this.reboundBuffer[hostString];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          hook = _ref[_i];
          current.push(hook);
        }
        _results = [];
        for (_j = 0, _len1 = current.length; _j < _len1; _j++) {
          hook = current[_j];
          pack = new Dispatch({
            method: "BIND",
            endpoint: hook.endpoint,
            host: [hook.host]
          });
          _results.push(this._sendOrConnect(pack, hook.callback, hook.context));
        }
        return _results;
      } else {
        console.log("Will rebind " + this.reboundBuffer[hostString].length + " endpoints in 3 seconds");
        return setTimeout(function() {
          return JSTP._rebind(hostString, true);
        }, 3000);
      }
    },
    send: function(host, string) {
      var socket;
      socket = this._get(host);
      socket.send(string);
      return console.log("%c Sent: " + string, "color: #0055FF");
    },
    _get: function(host) {
      var hostString;
      if (!(host instanceof Array)) {
        host = [host, 80];
      }
      hostString = host[0] + ":" + host[1];
      return this.connections[hostString];
    },
    trigger: function(pack) {
      var hooked, method, _i, _len, _ref, _results;
      method = pack.method.toLowerCase();
      _ref = this.bound;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        hooked = _ref[_i];
        switch (method) {
          case 'bind':
          case 'release':
            if (this._compare(hooked.endpoint, method, pack.endpoint.resource)) {
              _results.push(hooked.callback.call(hooked.context, pack));
            } else {
              _results.push(void 0);
            }
            break;
          case 'get':
          case 'post':
          case 'put':
          case 'delete':
          case 'patch':
            if (this._compare(hooked.endpoint, method, pack.resource)) {
              _results.push(hooked.callback.call(hooked.context, pack));
            } else {
              _results.push(void 0);
            }
            break;
          default:
            _results.push(void 0);
        }
      }
      return _results;
    },
    _compare: function(endpoint, method, resource, strict) {
      var el, endpointMethod;
      method = method.toLowerCase();
      endpointMethod = endpoint.method.toLowerCase();
      if (strict) {
        if (method === endpointMethod && resource.length === endpoint.resource.length) {
          for (el in endpoint.resource) {
            if (endpoint.resource[el] !== resource[el]) {
              return false;
            }
          }
          return true;
        }
      } else {
        if ((method === endpointMethod || endpointMethod === "*") && (resource.length === endpoint.resource.length)) {
          for (el in endpoint.resource) {
            if (endpoint.resource[el] !== "*" && endpoint.resource[el] !== resource[el]) {
              return false;
            }
          }
          return true;
        }
      }
      return false;
    },
    open: function(host) {
      var hostString;
      if (!(host instanceof Array)) {
        host = [host, 80];
      }
      hostString = host[0] + ":" + host[1];
      return this.connections[hostString] && this.connections[hostString].readyState === 1;
    },
    connect: function(host, callback) {
      var hostString;
      if (!(host instanceof Array)) {
        host = [host, 80];
      }
      hostString = host[0] + ":" + host[1];
      if (this.connections[hostString] && !this.connections[hostString].shuttedDown) {
        if (this.connections[hostString].callbacks.indexOf(callback) === -1) {
          console.log("Adding the callback since this is already connecting");
          return this.connections[hostString].callbacks.push(callback);
        } else {
          return console.warn("The callback was already hooked for onopen");
        }
      } else {
        this.connections[hostString] = new WebSocket('ws://' + hostString + '/');
        this.connections[hostString].parent = this;
        this.connections[hostString].host = host;
        this.connections[hostString].hostString = hostString;
        this.reboundBuffer[hostString] = [];
        this.connections[hostString].callbacks = [callback];
        this.connections[hostString].onopen = function() {
          var toCall, _i, _len, _ref;
          _ref = this.callbacks;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            toCall = _ref[_i];
            toCall();
          }
          return this.callbacks = [];
        };
        this.connections[hostString].onmessage = function(event) {
          console.log("%c Received: " + event.data, "color: #FF5500");
          return this.parent.dispatch(JSON.parse(event.data));
        };
        return this.connections[hostString].onclose = function() {
          var hooked, _i, _len, _ref;
          _ref = this.parent.bound;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            hooked = _ref[_i];
            if (hooked.host === this.host) {
              this.parent.reboundBuffer[this.hostString].push(hooked);
            }
          }
          if (this.parent.reboundBuffer[this.hostString].length > 0) {
            console.log("Rebinding to " + (this.host.join(':')));
          }
          this.parent._rebind(hostString);
          return this.shuttedDown = true;
        };
      }
    }
  };

}).call(this);
